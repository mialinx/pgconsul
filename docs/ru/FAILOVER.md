# FAILOVER

failover - это процесс незапланированного переключения мастер из-за поломки железа/сети на текущем мастере или падении процесса Postgres

## Процесс failover

Процесс failover начинается с того, что исчезает `leader_lock` в ZK.

Это может произойти в следующих случаях:

* Реальная пропажа сети / отключение от ZK
* PgConsul сам может отпустить лок, в случае если локальный Postgres неработоспособен (см вызовы `release_lock`, `release_lock_and_return_to_cluster`)

Далее одна (или несколько) реплик обнаруживают пропажу `leader_lock` и начинает процесс failover.

Процесс состоит из 3 частей
* Проверка возможности (`_can_do_failover`)
* Выбор следующего мастера (неожиданно тоже внутри `_can_do_failover`)
* Запуск (promote) нового мастера

### Проверка возможности

Реплика проверяет что:
* failover разрешен в настройках
* Таймлайн реплики совпадает с таймлайном кластера до failover
* с момента последнего failover прошло достаточно времени, что бы не переключаться "по-кругу"
* c момента исчезновения `leader_lock`-а прошло достаточно времени, что бы исключить флапы мастера
* мастер действительно недоступен по SQL протоколу, что бы исключить флапы ZK
* реплика закончила применение WAL, и готова к failover
* число живых реплик, более половины из тех, что составляли кворум.
  Это гарантирует что хотя бы на одной из них будет последний LSN с мастера.

### Выбор нового мастера

* все реплики, участвующие в выборе, останавливают применение WAL
* участники пытаются захватить лок `ELECTION_MANAGER_LOCK_PATH`, один из них захватывает и становится менеджером выборов
* все участники записывают свой текущий LSN в ZK
* менеджер сравнивает их определяет победителя, записывает результат в ZK
* победитель получает True при возврате из `_can_do_failover`, остальные False

### Запуск (promote) нового мастера

Победитель выборов
* захватывает `leader_lock`
* создает слоты репликации на новом мастере
* собственно делает pg_ctl promote
